; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; AUTOMATICALLY GENERATED CODE, DO NOT MODIFY
; UNLESS YOU REALLY, REALLY, REALLY MEAN IT !!
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; Code generated by : Dev-Object - V2.2.5
; Project name : Dev-Board
; File name : StringHashMap.pbi
; File Version : 1.0.0
; Programmation : In progress
; Programmed by : Guillaume Saumure
; AKA : StarBootics
; E-mail : gsaumure@cgocable.ca
; Creation Date : 21-06-2024
; Last update : 21-06-2024
; Coded for PureBasic : V6.11 LTS
; Platform : Windows, Linux, MacOS X
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; This is free and unencumbered software released into the public domain.
; 
; Anyone is free to copy, modify, publish, use, compile, sell, or
; distribute this software, either in source code form or as a compiled
; binary, for any purpose, commercial or non-commercial, and by any
; means.
; 
; In jurisdictions that recognize copyright laws, the author or authors
; of this software dedicate any and all copyright interest in the
; software to the public domain. We make this dedication for the benefit
; of the public at large and to the detriment of our heirs and
; successors. We intend this dedication to be an overt act of
; relinquishment in perpetuity of all present and future rights to this
; software under copyright law.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
; IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
; OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
; ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
; OTHER DEALINGS IN THE SOFTWARE.
; 
; For more information, please refer to <http://unlicense.org/>
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

DeclareModule StringHashMap
  
  Interface StringHashMap
    
    GetBucketKey.i()
    GetBucketValue.s()
    UpdateBucket(Value.s)
    LookUpBucket.i(Key.i)
    AddBucket.i(Key.i, Value.s)
    RemoveBucket.i(Key.i)
    ResetBuckets()
    NextBucket.i()
    BucketsCount.l()
    RemoveAllBuckets()
    Free()
    
  EndInterface
  
  Declare.i New(TableMax.l = 10)
  
EndDeclareModule

Module StringHashMap
  
  DisableDebugger
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Structures declaration <<<<<
  
  Structure Bucket
    
    Key.i
    Value.s
    *Next.Bucket
    
  EndStructure
 
  Structure Private_Members
    
    VirtualTable.i
    *ObjectDestructor
    TableMax.l
    *Table
    *CurrentBucket.Bucket
    CurrentIndex.l
    BucketsCount.l
    
  EndStructure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The ReachElement calculation macro <<<<<
  
  Macro ReachElement(StartPtr, Index)
    
    (StartPtr + (Index) * SizeOf(Integer))
    
  EndMacro
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Hash Function <<<<<
  
  Procedure.i HashFunction(*This.Private_Members, Key.i)
   
    Hash_Value.i = 1
    
    For HashingRoundID = 0 To 3
      Hash_Value = ((Hash_Value << 6) ! (Hash_Value >> 2) ! (Key << 6) ! (Key >> 2)) % *This\TableMax
    Next
    
    ProcedureReturn Hash_Value
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Getters <<<<<
  
  Procedure.i GetBucketKey(*This.Private_Members)
    
    If *This\CurrentBucket <> #Null
      ProcedureReturn *This\CurrentBucket\Key
    Else
      ProcedureReturn -1
    EndIf
    
  EndProcedure
  
  Procedure.s GetBucketObject(*This.Private_Members)
    
    If *This\CurrentBucket <> #Null
      ProcedureReturn *This\CurrentBucket\Value
    Else
      ProcedureReturn ""
    EndIf
   
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The UpdateBucket operator <<<<<
  
  Procedure UpdateBucket(*This.Private_Members, Value.s)
    
    If *This\CurrentBucket <> #Null
      *This\CurrentBucket\Value = Value
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The LookupBucket operator <<<<<
  
  Procedure.i LookupBucket(*This.Private_Members, Key.i)
    
    Index.l = HashFunction(*This, Key)
    *Temp.Integer = ReachElement(*This\Table, Index)
    *Cursor.Bucket = *Temp\i
    
    While *Cursor <> #Null
      
      If *Cursor\Key = Key
        *This\CurrentBucket = *Cursor
        ProcedureReturn #True
      EndIf
      
      *Cursor = *Cursor\Next
      
    Wend
    
    ProcedureReturn #False
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The AddBucket operator <<<<<
  
  Procedure.i AddBucket(*This.Private_Members, Key.i, Value.s)

    If LookupBucket(*This, Key) = #False
      
      *Bucket.Bucket = AllocateStructure(Bucket)
      *Bucket\Key = Key
      *Bucket\Value = Value
      
      Index.i = HashFunction(*This, Key)
      *Temp.Integer = ReachElement(*This\Table, Index)
      *Bucket\Next = *Temp\i
      *Temp\i = *Bucket
      *This\CurrentBucket = *Bucket
      *This\BucketsCount + 1
      
      ProcedureReturn 1
      
    Else
      
      UpdateBucket(*This, Value)
      
      ProcedureReturn 2
      
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The RemoveBucket operator <<<<<
  
  Procedure.i RemoveBucket(*This.Private_Members, Key.i)
    
    *This\CurrentBucket = #Null
    
    Index.l = HashFunction(*This, Key)
    *Temp.Integer = ReachElement(*This\Table, Index)
    *Cursor.Bucket = *Temp\i
    *Previous.Bucket = #Null
    
    While *Cursor <> #Null And *Cursor\Key <> Key
      *Previous = *Cursor 
      *Cursor = *Cursor\Next
    Wend
    
    If *Cursor = #Null
      ProcedureReturn #False
    EndIf
    
    If *Previous = #Null
     
      *Head = *Temp\i
      *Temp\i = *Cursor\Next
      
      FreeStructure(*Head)
      *This\BucketsCount - 1
      
    Else
      
      *Previous\Next = *Cursor\Next
      FreeStructure(*Cursor)
      *This\BucketsCount - 1
      
    EndIf
    
    ProcedureReturn #True
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The ResetBuckets operator <<<<<
  
  Procedure ResetBuckets(*This.Private_Members)
    
    *This\CurrentIndex = -1
    *This\CurrentBucket = #Null
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The NextBucket operator <<<<<
  
  Procedure.i NextBucket(*This.Private_Members)
    
    If *This\CurrentBucket = #Null And *This\CurrentIndex = -1
      
      *This\CurrentIndex = 0
      
      For Index = *This\CurrentIndex To *This\TableMax - 1
        
        *Temp.Integer = ReachElement(*This\Table, Index)
        *Cursor.Bucket = *Temp\i
        
        If *Cursor <> #Null
          *This\CurrentBucket = *Cursor
          *This\CurrentIndex = Index
          ProcedureReturn *This\CurrentBucket
        EndIf
        
      Next
      
    Else
      
      If *This\CurrentBucket\Next <> #Null
        *This\CurrentBucket = *This\CurrentBucket\Next
        ProcedureReturn *This\CurrentBucket
      Else
        
        *This\CurrentIndex + 1
        
        While *This\CurrentIndex < *This\TableMax
          
          *Temp.Integer = ReachElement(*This\Table, *This\CurrentIndex)
          *Cursor.Bucket = *Temp\i
          
          If *Cursor <> #Null
            *This\CurrentBucket = *Cursor
            ProcedureReturn *This\CurrentBucket
          EndIf
          
          *This\CurrentIndex + 1
          
        Wend
        
      EndIf
      
    EndIf
    
  EndProcedure

  Procedure.l BucketsCount(*This.Private_Members)
    
    ProcedureReturn *This\BucketsCount
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The RemoveAllBuckets operator <<<<<
  
  Procedure RemoveAllBuckets(*This.Private_Members)
    
    For Index = 0 To *This\TableMax - 1
      
      *Temp.Integer = ReachElement(*This\Table, Index)
      *Cursor.Bucket = *Temp\i
      
      If *Cursor <> #Null
        
        While *Cursor <> #Null
          
          *Temp2 = *Cursor
          *Cursor = *Cursor\Next
          FreeStructure(*Temp2)
          
        Wend
        
      EndIf
      
      *Temp\i = #Null
      
    Next
    
    *This\BucketsCount = 0
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Destructor <<<<<

  Procedure Free(*This.Private_Members)
    
    RemoveAllBuckets(*This)
    FreeMemory(*This\Table)
    FreeStructure(*This)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Constructor <<<<<

  Procedure.i New(TableMax.l = 10)
    
    *This.Private_Members = AllocateStructure(Private_Members)
    *This\VirtualTable = ?START_METHODS

    If TableMax < 10
      TableMax = 10
    EndIf
    
    *This\TableMax = TableMax
    
    *This\Table = *Table
    *This\Table = AllocateMemory(*This\TableMax * SizeOf(Integer))
    
    ProcedureReturn *This
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Virtual Table Entries <<<<<

  DataSection
    START_METHODS:
    Data.i @GetBucketKey()
    Data.i @GetBucketObject()
    Data.i @UpdateBucket()
    Data.i @LookUpBucket()
    Data.i @AddBucket()
    Data.i @RemoveBucket()
    Data.i @ResetBuckets()
    Data.i @NextBucket()
    Data.i @BucketsCount()
    Data.i @RemoveAllBuckets()
    Data.i @Free()
    END_METHODS:
  EndDataSection
  
  EnableDebugger
  
EndModule

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; <<<<< Code generated in : 00.001 seconds (88000.00 lines/second) <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

; <<<<<<<<<<<<<<<<<<<<<<<
; <<<<< END OF FILE <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<
; IDE Options = PureBasic 6.11 LTS (Linux - x64)
; Folding = ----
; EnableXP
; CompileSourceDirectory